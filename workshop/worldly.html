<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>worldly</title>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            background-color: black;
            text-align: center;
        }

        #canvas {
            background-color: deepskyblue;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script type="application/javascript" src="../js/angles.js"></script>
<script type="application/javascript" src="../js/vector.js"></script>
<script type="application/javascript" src="../js/canvas.js"></script>
<script type="application/javascript" src="../js/camera.js"></script>
<script type="application/javascript" src="../js/mouse.js"></script>

<script type="text/javascript">//<![CDATA[
let _planetRadius = 1737500; // m (size of the moon)
let _rocketHeight = 70; // m (height of the falcon 9)
let _initialScale = 1.6; // initial scale of main camera

let _lastMouseP = null;

let _contextProxy = null;
let _canvas = null;
let _mouse = null;
let _mainCamera = null;

class ContextProxy {
    // This translator takes the "normal to me" coordinates and rotations, and translates
    //  them so that they will appear on the canvas as I would expect.
    //
    // For example, I expect positive 'y' to go up, I expect positive 'x' to go right,
    //  and I expect a 90-degree rotation to point up on the positive 'y' axis.
    //
    // It should be clear to you how tedious this is, and if it is, you are probably screaming matrices.
    //  To which, I will say, later...

    // Also, it is not a real proxy because context has several nested layers, and I didn't want to proxy everything...
    // This seemed quicker somehow...

    #ctx = null;

    constructor(ctx) {
        this.#ctx = ctx;
    }

    rect(x, y, width, height)
    {
        this.#ctx.rect(x - (height / 2), y - (width / 2), height, width);
    }

    arc(x, y, radius, startAngle, endAngle, counterclockwise)
    {
        this.#ctx.arc(x, y, radius, startAngle - Angles.QUARTER_PI, endAngle - Angles.QUARTER_PI, counterclockwise ?? true);
    }

    translate(x, y)
    {
        this.#ctx.translate(x, -y);
    }

    rotate(degrees)
    {
        this.#ctx.rotate(Angles.toRadians(degrees));
    }

    createLinearGradient(x0, y0, x1, y1)
    {
        let dy = (y0 - y1) / 2;
        let dx = (x0 - x1) / 2;
        return this.#ctx.createLinearGradient(-dy, -dx, dy, dx);
    }

    beginPath()
    {
        return this.#ctx.beginPath();
    }

    save()
    {
        return this.#ctx.save();
    }

    restore()
    {
        return this.#ctx.restore();
    }

    fill()
    {
        return this.#ctx.fill();
    }

    stroke()
    {
        return this.#ctx.stroke();
    }

    set fillStyle (style) {
        this.#ctx.fillStyle = style;
    }

    set strokeStyle (style) {
        this.#ctx.strokeStyle = style;
    }
}

let _world = {
    objects: {
        planet: {
            p: new Vector(0, 0),
            rotation: 90, // degrees
            radius: _planetRadius, // m (size of the moon)
            gravity: 9.8, // m/s^2 (with earths gravity.)

            draw: function(ctx) {
                let grd = ctx.createLinearGradient(0, this.radius * 2.5, 0, 0);
                grd.addColorStop(0, "forestgreen");
                grd.addColorStop(1, "black");

                ctx.translate(this.p.x, this.p.y);
                ctx.rotate(this.rotation);

                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Angles.FULL_PI);
                ctx.fillStyle = grd;
                ctx.fill();
            },
        },

        rocket: {
            p: new Vector(0, _planetRadius),
            rotation: 90, // degrees
            width: 3.7, // m
            height: _rocketHeight, // m

            draw: function(ctx) {
                let grd = ctx.createLinearGradient(0, this.height, 0, 0);
                grd.addColorStop(0, "orange");
                grd.addColorStop(.1, "white");
                grd.addColorStop(1, "white");

                ctx.translate(this.p.x, this.p.y);
                ctx.rotate(this.rotation);

                ctx.beginPath();
                ctx.rect(0, 0, this.width, this.height);
                ctx.fillStyle = grd;
                ctx.fill();
            },
        },
    },
};

function draw(ctx, camera) {
    ctx.reset();
    ctx.translate(camera.p.x, camera.p.y);
    ctx.scale(camera.scale, camera.scale);

    for (const obj in _world.objects) {
        ctx.save();
        _world.objects[obj].draw(_contextProxy);
        ctx.restore();
    }
}

function update(dtm, dts) {
    if (_mouse.btn("left").isDown) {
        let deltaM = _mouse.p.subtract(_lastMouseP);
        _lastMouseP = _mouse.p;

        _mainCamera.p = _mainCamera.p.add(deltaM);
    }
}




function mainLoop(time, ctx) {
    let dtm = (performance.now() - time);

    update(dtm, dtm / 1000);
    draw(ctx, _mainCamera);

    window.requestAnimationFrame(function() {
        mainLoop(performance.now(), ctx);
    });
}

function init() {
    let canvas = document.querySelector("#canvas");
    let ctx = canvas.getContext("2d");

    _mouse = new Mouse(0, 0, { 1: "left" });
    _canvas = new Canvas(canvas, window.innerWidth, window.innerHeight);
    addEventListeners(canvas);

    _mainCamera = new Camera(new Vector(_canvas.width / 2, (_planetRadius * _initialScale) + (_canvas.height - _rocketHeight * _initialScale)), _initialScale);

    _contextProxy = new ContextProxy(ctx);

    mainLoop(performance.now(), ctx);
}
init();



function zoom(deltaY) {
    // To zoom, change the X and Y scale of the canvas.
    // Here, the scale is provided by the main camera (i.e. it works by moving the camera away from the subject).
    //
    // In order to keep the subject in frame, you need to move the camera.
    // When zooming with a mouse, the expectation is that the camera remain focused on the mouse cursor.

    // First determine how fast to zoom (I assume different mice and browsers will zoom at different rates).
    // This formula should probably factor in deltaY. However, with my browser and mouse, this works well with
    //  a consistent deltaYof 53.
    let zoomSpeedFactor = 0.0825;

    // Zoom in if scrolling up, zoom out if scrolling down.
    let zoomingOut = (deltaY > 0);

    // The zoom speed factor allows the zoom to be faster when zoomed way in.
    let deltaZ = (zoomingOut ? -(_mainCamera.scale * zoomSpeedFactor) : (_mainCamera.scale * zoomSpeedFactor));

    { // Prevent infinite zoom for no good reason.
        // The scale increases as you zoom in.

        if (!zoomingOut && (_mainCamera.scale + deltaZ) > 120) { // {0.00005) {
            deltaZ = (120 - _mainCamera.scale);
        }

        if (zoomingOut && (_mainCamera.scale + deltaZ) < 0.00005) {
            deltaZ = (0.00005 - _mainCamera.scale);
        }
    }

    // Get a translation vector from the camera to the mouse position.
    // This tells us the direction to move the camera, but because the world is about to be smaller,
    //  it doesn't tell how far to move the camera; hence the unit vector.
    let moveVector = _mainCamera.p.subtract(_mouse.p);
    moveVector = moveVector.normalize();

    // Next calculate the distance the camera needs to move, to keep the canvas at the mouse position.
    // Here it uses the planet's radius, but any object with a known size would work.
    // I'm calling it a magic number, because although the math works, it is a little odd.
    let magicNumber = (_planetRadius * deltaZ);
    moveVector = moveVector.multiply(magicNumber);

    _mainCamera.p = _mainCamera.p.add(moveVector);
    _mainCamera.scale += deltaZ;

    // Note: this is still not correct on the y translation...
}

function addEventListeners(canvas) {
    canvas.addEventListener('wheel', function(event) {
        _mouse.onScroll(event.deltaY);
        zoom(event.deltaY);
    });

    canvas.addEventListener('mousemove', function(event) {
        _mouse.onMove(event.clientX, event.clientY);
    });

    canvas.addEventListener('mousedown', function(event) {
        _mouse.onMouseDown(event.which, event.clientX, event.clientY);

        if (event.which === 1) {
            _lastMouseP = {
                x: event.clientX,
                y: event.clientY
            };
        }
    });

    canvas.addEventListener('mouseup', function(event) {
        _mouse.onMouseUp(event.which, event.clientX, event.clientY);
    });

    window.addEventListener('resize', function() {
        let deltaW = (window.innerWidth - _canvas.width);
        let deltaH = (window.innerHeight - _canvas.height);

        _canvas.updateSize(window.innerWidth, window.innerHeight);

        // It sorta works. Good enough.
        _mainCamera.p = new Vector(_mainCamera.p.x + deltaW, _mainCamera.p.y + deltaH);
    });
}

//]]></script>
</body>
</html>
