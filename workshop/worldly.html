<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>worldly</title>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            background-color: black;
            text-align: center;
        }

        #canvas {
            background-color: deepskyblue;
        }
    </style>
</head>
<body>
<canvas id="canvas"></canvas>

<script type="application/javascript" src="../js/angles.js"></script>
<script type="application/javascript" src="../js/vector.js"></script>
<script type="application/javascript" src="../js/canvas.js"></script>
<script type="application/javascript" src="../js/camera.js"></script>
<script type="application/javascript" src="../js/mouse.js"></script>

<script type="text/javascript">//<![CDATA[
let _planetRadius = 100;//1737500; // m (size of the moon)
let _rocketHeight = 70; // m (height of the falcon 9)
let _initialScale = 1;//1.6; // initial scale of main camera
let _maxScale = 120;
let _minScale = .00005;

let _lastMouseP = null;

let _contextProxy = null;
let _canvas = null;
let _mouse = null;
let _mainCamera = null;

class ContextProxy {
    // This translator takes the "normal to me" coordinates and rotations, and translates
    //  them so that they will appear on the canvas as I would expect.
    //
    // For example, I expect positive 'y' to go up, I expect positive 'x' to go right,
    //  and I expect a 90-degree rotation to point up on the positive 'y' axis.
    //
    // In addition, I want the center of my world to be at x = 0, y = 0.
    //
    // It should be clear to you how tedious this is, and if it is, you are probably screaming matrices.
    //  To which, I will say, later...

    // Also, it is not a real proxy because context has several nested layers, and I didn't want to proxy everything...
    // This seemed quicker somehow...

    #ctx = null;

    constructor(ctx) {
        this.#ctx = ctx;
    }

    rect(x, y, width, height)
    {
        this.#ctx.rect(x - (height / 2), y - (width / 2), height, width);
    }

    arc(x, y, radius, startAngle, endAngle, counterclockwise)
    {
        this.#ctx.arc(x, y, radius, startAngle - Angles.QUARTER_PI, endAngle - Angles.QUARTER_PI, counterclockwise ?? true);
    }

    translate(x, y)
    {
        this.#ctx.translate(x, -y);
        //this.#ctx.translate(x, y);
    }

    rotate(degrees)
    {
        this.#ctx.rotate(Angles.toRadians(degrees));
    }

    createLinearGradient(x0, y0, x1, y1)
    {
        let dy = (y0 - y1) / 2;
        let dx = (x0 - x1) / 2;
        return this.#ctx.createLinearGradient(-dy, -dx, dy, dx);
    }

    beginPath()
    {
        return this.#ctx.beginPath();
    }

    save()
    {
        return this.#ctx.save();
    }

    restore()
    {
        return this.#ctx.restore();
    }

    reset()
    {
        return this.#ctx.reset();
    }

    scale(x, y)
    {
        return this.#ctx.scale(x, y);
    }

    fill()
    {
        return this.#ctx.fill();
    }

    fillText(text, x, y, maxWidth)
    {
        return this.#ctx.fillText(text, x, y, maxWidth);
    }

    stroke()
    {
        return this.#ctx.stroke();
    }

    set fillStyle (style) {
        this.#ctx.fillStyle = style;
    }

    set strokeStyle (style) {
        this.#ctx.strokeStyle = style;
    }

    set font (font) {
        this.#ctx.font = font;
    }
}

let _world = {
    objects: {
        planet: {
            p: new Vector(0, 0),
            rotation: 90, // degrees
            radius: _planetRadius, // m (size of the moon)
            gravity: 9.8, // m/s^2 (with earths gravity.)

            draw: function(ctx) {
                let grd = ctx.createLinearGradient(0, this.radius * 2.5, 0, 0);
                grd.addColorStop(0, "forestgreen");
                grd.addColorStop(1, "black");

                ctx.translate(this.p.x, this.p.y);
                ctx.rotate(this.rotation);

                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Angles.FULL_PI);
                ctx.fillStyle = grd;
                ctx.fill();
            },
        },

        rocket: {
            p: new Vector(0, _planetRadius),
            rotation: 90, // degrees
            width: 3.7, // m
            height: _rocketHeight, // m

            draw: function(ctx) {
                let grd = ctx.createLinearGradient(0, this.height, 0, 0);
                grd.addColorStop(0, "orange");
                grd.addColorStop(.1, "white");
                grd.addColorStop(1, "white");

                ctx.translate(this.p.x, this.p.y);
                ctx.rotate(this.rotation);

                ctx.beginPath();
                ctx.rect(0, 0, this.width, this.height);
                ctx.fillStyle = grd;
                ctx.fill();
            },
        },
    },
};

function drawHud(ctx) {
    ctx.save();

    let x = 10;
    let y = 1;
    let ySpacing = 20;

    ctx.beginPath();
    ctx.font = "15px Arial";
    ctx.fillStyle = "white";

    ctx.fillText("World Coords | Screen Coords", x, y++ * ySpacing);
    ctx.fillText("Mouse: " + _mouse.p.toString() + " | " + translateFromWorld(_mouse.p).toString(), x, y++ * ySpacing);
    ctx.fillText("Left Down At: " + _mouse.left.downAt.toString() + " | " + translateFromWorld(_mouse.left.downAt).toString(), x + 10, y++ * ySpacing);
    ctx.fillText("Left Up At: " + _mouse.left.upAt.toString() + " | " + translateFromWorld(_mouse.left.upAt).toString(), x + 10, y++ * ySpacing);
    ctx.fillText("Camera: " + _mainCamera.p.toString() + " | " + translateFromWorld(_mainCamera.p).toString(), x, y++ * ySpacing);
    ctx.fillText("Scale: " + _mainCamera.scale, x, y++ * ySpacing);
    ctx.fillText("Canvas Center: " + new Vector(_canvas.width / 2, _canvas.height / 2).toString(), x, y++ * ySpacing);

    ctx.restore();
}

function draw(ctx, camera) {
    ctx.reset();

    ctx.save();

    //let screenCoords = translateFromWorld(camera.p);
    //ctx.translate(screenCoords.x, -screenCoords.y);
    ctx.translate(-camera.p.x + (_canvas.width / 2), -(camera.p.y + (_canvas.height / 2)));
    ctx.scale(camera.scale, camera.scale);

    for (const obj in _world.objects) {
        ctx.save();
        _world.objects[obj].draw(ctx);
        ctx.restore();
    }

    ctx.restore();

    drawHud(ctx);
}

function update(dtm, dts) {

}




function mainLoop(time, ctx) {
    let dtm = (performance.now() - time);

    update(dtm, dtm / 1000);
    draw(ctx, _mainCamera);

    window.requestAnimationFrame(function() {
        mainLoop(performance.now(), ctx);
    });
}

function init() {
    let canvas = document.querySelector("#canvas");
    let ctx = canvas.getContext("2d");

    //_mainCamera = new Camera(new Vector(_canvas.width / 2, (_planetRadius * _initialScale) + (_canvas.height - _rocketHeight * _initialScale)), _initialScale);
    _mainCamera = new Camera(new Vector(0, 0), _initialScale);
    _mouse = new Mouse(new Vector(0, 0));
    _canvas = new Canvas(canvas, window.innerWidth, window.innerHeight);
    addEventListeners(canvas);

    _contextProxy = new ContextProxy(ctx);

    mainLoop(performance.now(), _contextProxy);
}
init();

function zoom(deltaY) {
    // To zoom in and out on the mouse, what we need to do is calculate the
    //  mouses position before and after the scale change.
    // Then we move the camera by that amount. This keeps the mouse at the
    //  same location before and after the scaling.

    // First determine how fast to zoom (I assume different mice and browsers will zoom at different rates).
    // This formula should probably factor in deltaY. However, with my browser and mouse, this works well with
    //  a consistent deltaYof 53.
    let zoomSpeedFactor = 0.0825;

    // Zoom in if scrolling up, zoom out if scrolling down.
    let zoomingOut = (deltaY > 0);

    // Multiplying the zoom speed factor by the current scale allows the zoom to be faster when zoomed way in.
    let deltaScale = (zoomingOut ? -_mainCamera.scale * zoomSpeedFactor : _mainCamera.scale * zoomSpeedFactor);

    { // Prevent infinite zoom for no good reason.
        // The scale increases as you zoom in.
        // A negative scale will reverse the y coordinates, and scaling by 0 results in 0,
        //  so it is important to clamp the minimum to something greater than 0.

        if (_mainCamera.scale + deltaScale === 0) {
            deltaScale += (zoomingOut ? -.00000001 : .00000001);
        }

        if (!zoomingOut && (_mainCamera.scale + deltaScale) > _maxScale) {
            deltaScale = (_maxScale - _mainCamera.scale);
        }

        if (zoomingOut && (_mainCamera.scale + deltaScale) < _minScale) {
            deltaScale = (_minScale - _mainCamera.scale);
        }
    }

    let currentMouseP = _mouse.p.multiply(_mainCamera.scale);
    let newMouseP = _mouse.p.multiply(_mainCamera.scale + deltaScale);
    let deltaMouseP = newMouseP.subtract(currentMouseP);

    _mainCamera.moveBy(deltaMouseP, deltaScale);
}

function translateToWorld(x, y) {
    // The center of the world is at 0,0, which is the center of the screen.
    // However, the screen sees 0,0 as the top left point. It also sees positive y as moving down.
    // Here, the x,y is translated from screen coordinates to world coordinates.

    let ix = x;
    let iy = y;

    if (x instanceof Vector) {
        ix = x.x;
        iy = x.y;
    }

    return new Vector(ix - (_canvas.width / 2), (_canvas.height / 2) - iy).add(_mainCamera.p).divide(_mainCamera.scale);
}

function translateFromWorld(x, y) {
    // Here, the x,y is translated from world coordinates to screen coordinates.

    let ix = x;
    let iy = y;

    if (x instanceof Vector) {
        ix = x.x;
        iy = x.y;
    }

    let trans = new Vector(ix, iy).multiply(_mainCamera.scale).subtract(_mainCamera.p);
    return new Vector(trans.x + (_canvas.width / 2), (_canvas.height / 2) - trans.y);
}

let _lastMousePos = 0;
function addEventListeners(canvas) {
    // Disable context menu.
    canvas.oncontextmenu = function(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    canvas.addEventListener('wheel', function(event) {
        _mouse.onScroll(event.deltaY);
        zoom(event.deltaY);
    });

    canvas.addEventListener('mousemove', function(event) {
        let currentMouse = new Vector(event.clientX, event.clientY);
        if (_mouse.left.isDown) {
            let deltaM = currentMouse.subtract(_lastMousePos);

            _mainCamera.moveBy(new Vector(-deltaM.x, deltaM.y), 0);
        }

        // You cannot use the world coordinates to find the mouse delta.
        //  This is because the world is always moving to the mouse, meaning the mouses
        //  world coordinates remain the same. If they are not the same, something bad happened.
        _lastMousePos = currentMouse;

        _mouse.moveTo(translateToWorld(event.clientX, event.clientY));
    });

    canvas.addEventListener('mousedown', function(event) {
        let worldCoords = translateToWorld(event.clientX, event.clientY);
        _mouse.onMouseDown(event.which, worldCoords.x, worldCoords.y);

        if (event.which === 1) {
            _lastMouseP = worldCoords;
        }

        event.preventDefault();
        event.stopPropagation();
    });

    canvas.addEventListener('mouseup', function(event) {
        let worldCoords = translateToWorld(event.clientX, event.clientY);
        _mouse.onMouseUp(event.which, worldCoords.x, worldCoords.y);


        event.preventDefault();
        event.stopPropagation();
    });

    window.addEventListener('resize', function() {
        let deltaW = (window.innerWidth - _canvas.width);
        let deltaH = (window.innerHeight - _canvas.height);

        _canvas.updateSize(window.innerWidth, window.innerHeight);

        // It sorta works. Good enough.
        _mainCamera.moveBy(new Vector(deltaW, deltaH));
    });
}

//]]></script>
</body>
</html>
