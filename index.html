<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Thrust It!</title>

    <link rel="stylesheet" type="text/css" href=""/>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
        }

        body {
            height: 100vh;
            background-color: black;
            text-align: center;
        }

        #canvas {
            background-color: deepskyblue;
        }

        .controls {
            width: 1024px;
            margin-left: auto;
            margin-right: auto;
            background-color: #ddffff;
            text-align: left;
            box-sizing: border-box;
            padding: 10px 20px;
            font-size: 15px;
            font-family: "monospace";
        }

        .controls .bottom {
            margin-top: 20px;
            font-size: 12px;
            line-height: 20px;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>
<div class="controls">
    <div class="left">
        <div>Speed: <span id="speed"></span></div>
        <div class="bottom">
            <div>Space to activate thruster.</div>
            <div>Left and Right arrows to control gimbal.</div>
        </div>
    </div>
</div>


<script type="text/javascript">//<![CDATA[
let screenWidth = 1024;
let screenHeight = 768;

let canvas = document.querySelector("#canvas");
let speedReadout = document.querySelector("#speed");
let ctx = canvas.getContext("2d");
canvas.width = screenWidth;
canvas.height = screenHeight;

let keysDown = {};
let gravity = { x: 0, y: -9.8 };
let rocket = { // Thrust and mass roughly based on a fully loaded falcon 9.
    v: { x: 0, y: 0 },
    initP: { x: screenWidth / 2, y: 568 },
    p: { x: screenWidth / 2, y: 568 },
    width: 50,
    height: 150,
    mass: 500000, // kg
    payload: 20000, // kg

    engine: {
        maxGimbal: 4, // degrees
        maxThrust: 7000000, // N
        thrust: 7000000,
        gimbal: 0,
        getThrust: function() {
            // The gimbal angle is relative to the angle of the rocket. For now, that angle is simply 90 degrees.
            let angle = _angles.toRadians(90 - Math.min(this.gimbal, this.maxGimbal));

            return _vector.fromAngle(angle, Math.min(this.thrust, this.maxThrust));
        },
        mass: 4000, // kg
        burnTime: 0,
    },

    totalMass: function () {
        return (this.engine.mass + this.mass + this.payload);
    },

    updatePos: function () {
        this.p.x -= this.v.x;
        this.p.y -= this.v.y;

        if (this.p.y > this.initP.y) {
            this.p.y = this.initP.y;
        }
    },
};

let _angles = {
    PI_180: (Math.PI / 180),
    FULL_PI: (2 * Math.PI),
    HALF_PI: (Math.PI),
    QUARTER_PI: (.5 * Math.PI),

    toDegrees: function (radians) {
        return (radians / this.PI_180);
    },

    toRadians: function (degrees) {
        return (degrees * this.PI_180);
    },
};

let _vector = {
    getMagnitude: function(vector) {
        return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
    },

    addV: function (v1, v2) {
        return {
            x: (v1.x + v2.x),
            y: (v1.y + v2.y)
        };
    },

    divide: function (vector, denominator) {
        return {
            x: (vector.x / denominator),
            y: (vector.y / denominator)
        };
    },

    multiply: function (vector, multiplier) {
        return {
            x: (vector.x * multiplier),
            y: (vector.y * multiplier)
        };
    },

    normalize: function (vector) {
        return this.divide(vector, this.getMagnitude(vector));
    },

    getAngle: function (vector) {
        let tan = Math.atan2(vector.y, vector.x);
        return (tan < 0 ? (_angles.FULL_PI + tan) : tan);
    },

    fromAngle: function (angle, magnitude) {
        return {
            x: (Math.cos(angle) * magnitude),
            y: (Math.sin(angle) * magnitude),
        }
    },

    toString: function (vector, rnd) {
        return "(" + vector.x.toFixed(rnd) + ", " + vector.y.toFixed(rnd) + ")";
    },
};

function drawBoard() {
    ctx.beginPath();
    ctx.arc(screenWidth / 2, 2500, 2000, 0, _angles.FULL_PI);
    ctx.fillStyle = "forestgreen";
    ctx.fill();


    ctx.beginPath();
    ctx.rect(rocket.initP.x - 50, rocket.initP.y + 50, 100, 75);
    ctx.fillStyle = "#d7d2f1";
    ctx.fill();
}

function drawRocket() {
    ctx.save();
    ctx.beginPath();

    ctx.translate(rocket.p.x, rocket.p.y);
    //ctx.rotate(_vector.getAngle(rocket.v));

    let halfW = (rocket.width / 2);
    let halfH = (rocket.height / 2);

    // Only using 1/4 of the gimbal for display. Looks better.
    let gimbal = _angles.QUARTER_PI - _vector.getAngle(rocket.engine.getThrust());

    if (keysDown.space) {
        let rand = randomInt(-2, 2);
        ctx.beginPath(); // flame
        ctx.moveTo((-rocket.width / 3) - rand, halfH + halfW + 3);
        ctx.lineTo(randomInt(-2, 2) + _angles.toDegrees(gimbal), rocket.height + randomInt(-2, 2));
        ctx.lineTo((rocket.width / 3) + rand, halfH + halfW + 3);
        ctx.fillStyle = "#ff4500";
        ctx.fill();

        ctx.beginPath(); // fire
        ctx.arc(0, halfH + halfW, (rocket.width / 3) + rand, 0, _angles.FULL_PI);
        ctx.fillStyle = "#ff4500";
        ctx.fill();
    }


    { // thruster
        let normB = 1 - (rocket.engine.burnTime / Math.max(rocket.engine.burnTime, 5));
        let grdHeight = (halfH + halfW) * 5;
        let grd = ctx.createLinearGradient(0, 0, 0, grdHeight);
        grd.addColorStop(0, "darkgrey");
        grd.addColorStop(Math.max(normB, .28), "black");

        ctx.beginPath();
        ctx.arc(0, halfH + halfW - 6, halfW, -gimbal, Math.PI + -gimbal, true);
        ctx.fillStyle = grd;
        ctx.fill();
    }


    { // body
        let grd = ctx.createLinearGradient(-halfW, 0, halfW, 0);
        grd.addColorStop(0, "#bfc1c2");
        grd.addColorStop(.5, "#dcdcdc");
        grd.addColorStop(1, "#bfc1c2");

        ctx.beginPath();
        ctx.rect(-rocket.width / 2, -halfH, rocket.width, rocket.height);
        ctx.fillStyle = grd;
        ctx.fill();
    }

    { // nose
        let grd = ctx.createRadialGradient(0, -halfH, halfW, 0, 10, halfW);
        grd.addColorStop(0, "#dcdcdc");
        grd.addColorStop(.3, "#bfc1c2");
        grd.addColorStop(1, "#bfc1c2");

        ctx.beginPath();
        ctx.arc(0, -halfH, halfW, 0, Math.PI, true);
        ctx.fillStyle = grd;
        ctx.fill();
    }


    ctx.restore();
}

function drawReadout() {
    speedReadout.innerHTML = (rocket.v.y < 0 ? "-" : " ") + _vector.getMagnitude(rocket.v).toFixed(1) + " m/s" +
        " (" + rocket.v.x.toFixed(1) + ", " + rocket.v.y.toFixed(1) + ")" +
        " " + _angles.toDegrees(_vector.getAngle(rocket.v)) + "&deg;"
    ;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawBoard();
    drawRocket();
    drawReadout();
}


function update(dtm, dts) {
    rocket.engine.gimbal = 0;

    if (keysDown.space) {
        rocket.engine.burnTime += dts;

        if (keysDown.ArrowLeft) {
            rocket.engine.gimbal = 4;
        }
        else if (keysDown.ArrowRight) {
            rocket.engine.gimbal = -4;
        }
        else {
            rocket.engine.gimbal = 0;
        }

        // The force is the magnitude of the thrust vector.
        let force = _vector.getMagnitude(rocket.engine.getThrust());
        let accel = (force / rocket.totalMass()); // The acceleration depends on the engine's thrust and the total mass of the rocket.
        accel *= dts; // acceleration since last frame.

        // To apply the acceleration in the direction of the thrust, you need to get the thrust direction.
        let thrustN = _vector.normalize(rocket.engine.getThrust()); // The unit vector represents the direction of the thrust.
        let accelV = _vector.multiply(thrustN, accel); // Then create the acceleration vector.

        rocket.v = _vector.addV(rocket.v, accelV); // Apply the acceleration
    }

    // Only apply gravity if the rocket is not on the launch pad.
    if (rocket.p.y < rocket.initP.y) {
        // Really, gravity should always be applied. But whether you move depends on your collision detection.

        // Gravity is applied to all objects equally regardless of mass. So we just need to know how much gravity has happened since the last frame.
        rocket.v = _vector.addV(rocket.v, _vector.multiply(gravity, dts));
    }
    else if (rocket.v.y < 0) {
        rocket.v = { x: 0, y: 0 };
    }

    rocket.updatePos();
}


let time = performance.now();
function mainLoop() {
    let dtm = (performance.now() - time);

    update(dtm, dtm / 1000);

    draw();

    time = performance.now();
    window.requestAnimationFrame(mainLoop);
}
mainLoop();


window.addEventListener('keydown', function (event) {
    if (event.key === ' ') {
        keysDown.space = true;
    }
    else {
        keysDown[event.key] = true;
    }
});

window.addEventListener('keyup', function (event) {
    if (event.key === ' ') {
        delete keysDown.space;
    }
    else {
        delete keysDown[event.key];
    }
});


function randomInt(min, max) { // min and max included
    return Math.floor(Math.random() * (max - min + 1) + min);
}

//]]></script>
</body>
</html>
